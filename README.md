# CS202_Prog2/ Programming Systems /Winter 2018
*** Make sure to read the Background Information first!  
It applies to all programming assignments this term***



**THIS IS NO DESIGN WRITEUP and NO UML DIAGRAM for Program #2 ** 
Program #2 – Purpose 
In our first programming assignment, we experimented with the notion of OOP and  breaking the problem down into multiple classes building a relatively large system for a  delivery program. The purpose of that assignment was to get to know how we can create  classes that have different relationships. In program #2 our focus shifts to getting  experience developing a hierarchy that can be used with dynamic binding – so that the  application program can use one line of code to call one of many functions. To get the full  benefit of dynamic binding, we will look at a smaller problem with a predefined design. 
Program #2 – General Information 
My daughter got married this June and with it came many out of town visitors that stayed  with us. We had a variety of age groups from kids, young adults, and their parents. Finding  activities that everyone wanted to participate in and that were successful was a challenge.  At one point we divided up because it just didn’t work for the entire gang to do the same  activity. It was either boring or too challenging for one set of people. I felt bad when I took  the young adult to the rose garden and sat around like an 80 year old. Although it was  beautiful, she was far more interested in voodoo donuts! I wish I had a program that would  have helped me select the right activity based on the person’s age, interests, and skill level. 
Program #2 – Building a Hierarchy using Dynamic Binding 
For your second program, you will be creating a C++ OOP solution to support at least three different types of activities. Create a base class for the general form of activity. This should  be an abstract base class since we would never a general activity without knowing the  specifics.  
Then, create three different types of specific types of activities that will be derived from  the general one. Implement the following two choices and then ADD ONE OTHER of your  own choice. Make your type of activity similar to the other two but yet different!  
• Athletic Activity: This requires athletic skills, driving to a location and possibly  equipment needed. Examples could be wind surfing, jet skiing, hiking, kayaking, etc. some of these might have age or athletic requirements. 
• Site Seeing Activity. This would require the ability to get to a location, we would  need to know the hours of operation and a description of what we would be seeing. 
CS202 Summer 2018 Program #2 
If parking is a problem (like the Rose Garden) it should recommend taking Uber.  And, if any athletics are involved it should indicate the difficulty (e.g., Washington  Park requires considerable walking and walking shoes). For someplace like  voodoo, it requires indicating dietary constraints (e.g., my guest thought you could  eat lunch there!). 
The purpose of this assignment is to use and experience dynamic binding. The requirement  for this application is to have at least three DIFFERENT types of classes, derived from  a common abstract base class! To use dynamic binding, there needs to be a self-similar  interface among the derived class methods. In this case, for all types of activities, the user  would like to add a new activity, remove an activity, display all possible activities, mark  an activity as being done, and rate an activity about how well it met your expectations. In  the real world, there will be some differences as well, although there shouldn’t be too many.  Make sure to find at least one method that is different so that you can experience how  to resolve such differences. 
Program #2 – Data Structure Requirements 
With program #2, we need a Circular Linked List of base class pointers. Then using upcasting, each node can point to the appropriate type of activity. Implementation of the  required data structure(s) requires full support of insert, removal, display, retrieval, and  remove-all. This CLL allows a client to build a list for a variety of activities that they are  considering doing with their guests. The CLL should always continue with where they left  off performing activities (we don’t always want to start at the same place each time)! 
ALL repetitive algorithms should be implemented recursively  to prepare for our midterm proficiency demos! DO NOT break  the CLL. It is a CLL not a LLL!! 
Program #2 – Important C++ Syntax 
Remember to support the following constructs as necessary: 
1. Every class should have a default constructor 
2. Every class that manages dynamic memory must have a destructor 3. Every class that manages dynamic memory must have a copy constructor 4. If a derived class has a copy constructor, then it MUST have an initialization list  to cause the base class copy constructor to be invoked 
5. Make sure to specify the abstract base class’ destructor as virtual 
IMPORTANT: OOP and dynamic binding are THE PRIMARY GOALS of this  assignment!
---------------------------------------------------------------------------

EFFICIENCY WRITE UP:
I think the classes and overall design for this program performed well for the time given, however there were a few functionalities that I wanted to create but didn't end up working correctly or as well as I had hoped (such as the change subject function, and the option to the remove one question) . And I do know that I could have used some extra time to put more effort into the second two question subject classes. However I think that my classes, as far as being object oriented, worked well and met the requirements. All of the classes in my hierarchy (which included the base class for a question and 3 derived classes, dynamically bond question subject classes) preformed similar functions, however they all revolved around different computer science subjects. The only question subject that had a clear difference in functionality was my data structure class, which had an ‘example’  function, displaying info on various kinds of data structures. In order to get this function called only in the case that we are pointing to the data structure class object, I needed to use upcasting. As far as the aspects of my program that are not object oriented, that would be the node class and the array of doubly linked list manager class. And in the end, I think for the purpose of this program ( which was to epirence dynamic binding), I think the setup of my hierarchy worked pretty well.
I think that using an Array of doubly linked list served its purpose well however I think that the same functionality could have been achieved with just an array of linear linked lists. I feel like there was never a point in my program that I felt I really benefited from having a previous pointer. Although I suppose for recursive inserting or deleting in the middle of a list, it would be beneficial to have easy access to a previous pointer. But I do feel like for the most part, its extra time spent managing a previous pointer, and also creates some unnecessary overhead in my eyes. 
I think in the end my code turned out fairly alright as far as efficiency. Like mentioned I do think that with a slightly difference data structure the program may be more efficient. And I know that given more time, there were definitely aspect that I could have worked on in order to keep my program as efficient as possible. 



GDB WRITE UP:
While working on my program, GDB again proved to make the testing process much smoother. It really helps to pinpoint where my programs going wrong and why. And lets me confirm that I am calling the correct functions, and assigning variables to the correct values/ addresses. One particular kind of situation is if I got a segfault, by running my program through GDB I can see the specific spot were my program crashed, while testing my values at the same time. Some functions like calculating the cost and removing a specific vehicle, debugging them through GDB helped a lot to really see where and why my program was failing. In the future I would like to be able to see how I could test my program, and resume from just before where the program crashed. Because it seems pretty inconvenient to have to re-enter all the information from the beginning to retest it (and especially since the page needs to be refreshed very often). But I think overall my approach to debugging my program is pretty successful. Although Im sure there are many tools within GDB that would greatly enhance this process, the way ive been doing it has improved my debugging experience in general. 
